#!/bin/bash
# -----------------------------------------------------------------------------
# fastIPvanish - a shell script to find the most responsive IPVanish VPN server
#
# Copyright 2016, Chris Marsh <https://github.com/chris-marsh/fastIPvanish>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License at
# <http://www.gnu.org/licenses/> for more details.
#
# Requirements: awk, grep, ping & sed
#
# -----------------------------------------------------------------------------

usage() {
    echo 'USAGE'
    echo '    fastIPvanish [-l] [-d] [-W] [-Wr] [-t file] [-c file] filter'
    echo
    echo 'DESCRIPTION'
    echo '    fastIPvanish will ping the servers of IPVanish, returning the times'
    echo '    and show the fastest responding server. Optionally, a config file'
    echo '    can be written to file and used to start an openvpn session.'
    echo
    echo 'OPTIONS'
    echo '    -l    - list the ping result from each server'
    echo '    -W    - write a vpn config to file'
    echo '    -Wr   - write a vpn config file and start/restart openvpn'
    echo '    -d    - output a vpn config'
    echo '    -t    - specify a template file, default is ./template/default.tmpl'
    echo '    -c    - specify an output config file, default is ./config.ovpn'
    echo '    -h    - outputs this message'
    echo
    echo 'EXAMPLES'
    echo '    fastIPvanish -Wr -d London'
    echo '    fastIPvanish -d US'
    echo '    fastIPvanish -Wr New-York'
    echo '    fastIPvanish -W Amsterdam'
    exit 1
}

# Helper function, show a yes/no question and loop until given a valid response
# usage: ask "question" [default]
ask() {
    while true; do
        read -p "$1 [Y/n] " response
        case $response in
            [Yy]* ) return 0 ;;
            [Nn]* ) return 1 ;;
            "" )
                if [ "$2" = "Y" ] ; then
                    return 0
                elif [ "$2" = "N" ] ; then
                    return 1
                fi ;;
        esac
    done
}

# Helper function, return the qualified path of this script
# usage: thePath=$(scriptPath)
script_path() {
    # pushd `dirname $0` > /dev/null
    # pwd
    echo $(CDPATH= cd -- "$(dirname -- "$0")" && pwd -P)
}

# Write an openvpn config file using a template
# Global variables are read here;
#   $best_server_url
#   $opt_template_dir
write_config() {
    login_conf=$(script_path)'/etc/login.conf'
    cert_file=$(script_path)'/etc/ca.ipvanish.com.crt'
    sed -e "s|SERVER_HERE|$best_server_url|g" -e "s|LOGIN_HERE|$login_conf|g" -e "s|CERT_HERE|$cert_file|g" "$opt_template_dir"
}

# Insert line break if argument is true
line_space_if() {
    if [ "$1" = true ] ; then
        echo
    fi
}

# set temporary file and delete if exists
cleanup_temp_file() {
    if [ -f $temp_file ]; then
        rm $temp_file >/dev/null 2>/dev/null
    fi
}

# At least one argument is needed for the search opt_filter
[[ $1 ]] || usage

# Initialize the options
opt_filter=''
opt_list_pings=false
opt_template_dir=$(script_path)'/templates/default.tmpl'
opt_config_output_file=$(script_path)'/config.ovpn'
opt_config_to_file=false
opt_config_to_output=false
opt_restart_openvpn=false

# Argument parsing
while [[ $1 ]]; do
    case "$1" in
        '-l') opt_list_pings=true ;;
        '-W') opt_config_to_file=true ;;
        '-Wr') opt_config_to_file=true ; opt_restart_openvpn=true ;;
        '-d') opt_config_to_output=true ;;
        '-t') opt_template_dir=$2 ; shift ;;
        '-c') opt_config_output_file=$2 ; shift ;;
        '-h'|'--help') usage ;;
        -*) echo "fastIPvanish: Option '$1' is not valid." ; exit 128 ;;
        *) opt_filter=$1 ;;
    esac
    shift
done

# Make sure we have a search opt_filter
if [ "$opt_filter" = "" ] ; then
    usage;
fi

# Initialize the variables
best_ping_time="999999"
best_server_url=""
temp_file=$(script_path)'/fastIPvanish.tmp'

echo 'Starting server pings ... waiting ...'

cleanup_temp_file

# Start reading the server file one line at a time
while IFS='' read -r line || [[ -n "$line" ]] ; do

    # Check the cli argument is a substring of the line
    if ! [ "${line/$opt_filter}" = "$line" ] ; then

        # Create the server url from the line
        server_url=$(echo $line | awk -F'-' '{print $(NF-1) "-" $NF ".ipvanish.com"}')

        # Make a short ping and save result to temp file
        echo $server_url'='$(ping -c 1 -q -s 16 -w 1 -W 1 $server_url 2> /dev/null | grep avg | awk -F'/' '{print $5}') >> $temp_file &
    fi
done < $(script_path)'/etc/servers.list'
wait

line_space_if  "$opt_list_pings"

if [ -f $temp_file ] ; then
    # Read in results from the temp file
    while IFS='' read -r line || [[ -n "$line" ]] ; do
        server_url=$(echo $line | awk -F'=' '{print $1}')
        time_str=$(echo $line | awk -F'=' '{print $2}')

        # Remove decimal point for easier number comparison
        ping_time=$(echo $time_str | sed s/[^0-9]//g)

        # Check time is a number not a string message
        case $ping_time in                                                                           
            ''|*[!0-9]*)                                                                    
                if [ "$opt_list_pings" = true ] ; then 
                    echo $server_url' : Error'
                fi
                ;;                                                         
            *)  
                if [ "$opt_list_pings" = true ] ; then
                    echo $server_url' : '$time_str
                fi
                # If time is less than previous pings, store the server_url & time
                if [ "$ping_time" -lt "$best_ping_time" ] ; then                                   
                    best_server_url=$server_url                                      
                    best_ping_time=$ping_time                                                  
                fi ;;                                                                    
        esac         
    done < $temp_file
    line_space_if  "$opt_list_pings"
    cleanup_temp_file
fi

if [ "$best_server_url" = "" ] ; then
    echo "fastIPvanish: No servers found matching: $opt_filter"
    exit 1
fi

best_ping_time=$(echo $best_ping_time | sed 's/...$/.&/')
echo "Best ping time was "$best_server_url" @ "$best_ping_time"ms"

if [ $opt_config_to_output = true ] ; then
    echo
    write_config
fi

# Create a new openvpn config file from a template and the fastest server_url found
if [ $opt_config_to_file = true ] ; then
    echo -e "\nSaving config file: "$opt_config_output_file
    write_config > "$opt_config_output_file"
    if [ $opt_restart_openvpn = true ] ; then
        if ask "Stop any running openvpn process and start openvpn with new config?" "Y"  ; then
            # Check for root privileges, NOTE: $EUID is not available on busybox/openelec
            if [ "$(id -u)" = "0" ] ; then
                # Check if openvpn is already running and stop it if neccesary
                openvpn_pid=$(pidof openvpn)
                if [ $openvpn_pid ] ; then
                    kill $openvpn_pid
                    wait $openvpn_pid
                fi
                openvpn "$opt_config_output_file" &
            else
                echo 'fastIPvanish: root privileges are required for -Wr to start/stop openvpn'
                exit 126
            fi
        fi
    fi
fi
